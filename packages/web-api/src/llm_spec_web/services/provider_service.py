"""Provider config service backed by llm-spec.toml (no DB)."""

from __future__ import annotations

import tomllib
from datetime import UTC, datetime
from pathlib import Path
from typing import Any

from llm_spec_web.config import settings
from llm_spec_web.core.exceptions import NotFoundError


class ProviderService:
    """Provider service that persists config in llm-spec.toml only."""

    def _toml_path(self) -> Path:
        return Path(settings.app_toml_path)

    def _read(self) -> dict[str, Any]:
        path = self._toml_path()
        if not path.exists():
            return {}
        with open(path, "rb") as f:
            return tomllib.load(f)

    def _format_toml_value(self, value: Any) -> str:
        if isinstance(value, str):
            escaped = value.replace("\\", "\\\\").replace('"', '\\"')
            return f'"{escaped}"'
        if isinstance(value, bool):
            return "true" if value else "false"
        if isinstance(value, (int, float)):
            return str(value)
        if isinstance(value, list):
            return "[" + ", ".join(self._format_toml_value(v) for v in value) + "]"
        if isinstance(value, dict):
            items = ", ".join(f"{k} = {self._format_toml_value(v)}" for k, v in value.items())
            return "{ " + items + " }"
        return self._format_toml_value(str(value))

    def _write(self, data: dict[str, Any]) -> None:
        lines: list[str] = []
        lines.append("# llm-spec.toml - Auto-generated by web UI")
        lines.append("# Provider config is managed in TOML only.")
        lines.append("")

        providers = data.get("providers", {})
        if isinstance(providers, dict):
            for provider in sorted(providers.keys()):
                value = providers[provider]
                if not isinstance(value, dict):
                    continue
                lines.append(f"[providers.{provider}]")
                for k in ("api_key", "base_url", "timeout", "api_family"):
                    if k in value:
                        lines.append(f"{k} = {self._format_toml_value(value[k])}")
                for k, v in value.items():
                    if k not in {"api_key", "base_url", "timeout", "api_family"}:
                        lines.append(f"{k} = {self._format_toml_value(v)}")
                lines.append("")

        channels = data.get("channels", [])
        if isinstance(channels, list):
            for ch in channels:
                if not isinstance(ch, dict):
                    continue
                lines.append("[[channels]]")
                for k in ("name", "description", "api_key", "base_url", "timeout"):
                    if k in ch:
                        lines.append(f"{k} = {self._format_toml_value(ch[k])}")
                cproviders = ch.get("providers", [])
                if isinstance(cproviders, list):
                    for cp in cproviders:
                        if not isinstance(cp, dict):
                            continue
                        lines.append("")
                        lines.append("  [[channels.providers]]")
                        for k in ("name", "routes", "models"):
                            if k in cp:
                                lines.append(f"  {k} = {self._format_toml_value(cp[k])}")
                lines.append("")

        path = self._toml_path()
        path.parent.mkdir(parents=True, exist_ok=True)
        path.write_text("\n".join(lines), encoding="utf-8")

    def _row(self, provider: str, payload: dict[str, Any]) -> dict[str, Any]:
        return {
            "provider": provider,
            "api_type": str(payload.get("api_family") or provider),
            "base_url": str(payload.get("base_url", "")),
            "timeout": float(payload.get("timeout", 30.0)),
            "extra_config": {
                k: v
                for k, v in payload.items()
                if k not in {"api_key", "base_url", "timeout", "api_family"}
            },
            "updated_at": datetime.now(UTC),
        }

    def list_providers(self) -> list[dict[str, Any]]:
        data = self._read()
        providers = data.get("providers", {})
        if not isinstance(providers, dict):
            providers = {}
        return [
            self._row(p, v if isinstance(v, dict) else {}) for p, v in sorted(providers.items())
        ]

    def get_provider(self, provider: str) -> dict[str, Any]:
        data = self._read()
        providers = data.get("providers", {})
        if not isinstance(providers, dict) or provider not in providers:
            raise NotFoundError("ProviderConfig", provider)
        value = providers[provider]
        return self._row(provider, value if isinstance(value, dict) else {})
